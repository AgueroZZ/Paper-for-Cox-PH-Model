else{
u <- runif(N)
x <- runif(N,min = -5, max = 5)
truefunc <- function(x) 1.5*(sin(0.8*x))
eta <- truefunc(x)
}
failtimes <- c()
for (i in 1:N) {
hazz <- haz * exp(eta[i])
cumhaz <- cumsum(hazz*0.001)
Surv <- exp(-cumhaz)
failtimes[i] <- tdom[colSums(outer(Surv, u[i], `>`))]
}
data <- data_frame(x = x,times = failtimes, entry = rep(0,length(length(u))),censoring = ifelse(failtimes >= timelim,yes = 0, no=1))
for (i in 1:length(data$censoring)) {
if (data$censoring[i] == 1) {data$censoring[i] <- rbinom(n = 1,size = 1,prob = 0.9)}
}
data <- rename(data,exposure = x)
data <- data %>% as_tibble() %>%
mutate(exposure_binned = abcoxph:::bin_covariate(exposure,bins = RW2BINS,type = "equal"))
}
else if (bas == "regular") {
timelim <- 200
tdom <- seq(0, timelim, by = 0.001)
haz <- rep(0, length(tdom))
haz <- 0.03 * cos(0.15*tdom) + 0.05
true <- data.frame(time = tdom, hazard = haz)
if(truth == "smooth"){
u <- runif(N)
x <- runif(N,min = 0, max = 6)
truefunc <- function(x) log((x + 1)^2) - 1
eta <- truefunc(x)
}
else{
u <- runif(N)
x <- runif(N,min = -5, max = 5)
truefunc <- function(x) 1.5*(sin(0.8*x))
eta <- truefunc(x)
}
failtimes <- c()
for (i in 1:N) {
hazz <- haz * exp(eta[i])
cumhaz <- cumsum(hazz*0.001)
Surv <- exp(-cumhaz)
failtimes[i] <- tdom[colSums(outer(Surv, u[i], `>`))]
}
data <- data_frame(x = x,times = failtimes, entry = rep(0,length(length(u))),censoring = ifelse(failtimes >= timelim,yes = 0, no=1))
for (i in 1:length(data$censoring)) {
if (data$censoring[i] == 1) {data$censoring[i] <- rbinom(n = 1,size = 1,prob = 0.9)}
}
data <- rename(data,exposure = x)
data <- data %>% as_tibble() %>%
mutate(exposure_binned = abcoxph:::bin_covariate(exposure,bins = RW2BINS,type = "equal"))
}
else if (bas == "three_pieces") {
timelim <- 300
tdom <- seq(0, timelim, by = 0.001)
haz <- rep(0, length(tdom))
haz[1:round(length(haz)/3)] <- 0.01
haz[(round(length(haz)/3) + 1):(round(1.5*length(haz))/3)] <- 0.25
haz[(round(1.5*length(haz)/3) + 1):length(haz)] <- 0.5
true <- data.frame(time = tdom, hazard = haz)
if(truth == "smooth"){
u <- runif(N)
x <- runif(N,min = 0, max = 6)
truefunc <- function(x) log((x + 1)^2) - 1
eta <- truefunc(x)
}
else{
u <- runif(N)
x <- runif(N,min = -5, max = 5)
truefunc <- function(x) 1.5*(sin(0.8*x))
eta <- truefunc(x)
}
failtimes <- c()
for (i in 1:N) {
hazz <- haz * exp(eta[i])
cumhaz <- cumsum(hazz*0.001)
Surv <- exp(-cumhaz)
failtimes[i] <- tdom[colSums(outer(Surv, u[i], `>`))]
}
data <- data_frame(x = x,times = failtimes, entry = rep(0,length(length(u))),censoring = ifelse(failtimes >= timelim,yes = 0, no=1))
for (i in 1:length(data$censoring)) {
if (data$censoring[i] == 1) {data$censoring[i] <- rbinom(n = 1,size = 1,prob = 0.9)}
}
data <- rename(data,exposure = x)
data <- data %>% as_tibble() %>%
mutate(exposure_binned = abcoxph:::bin_covariate(exposure,bins = RW2BINS,type = "equal"))
}
else if (bas == "extreme") {
timelim <- 300
tdom <- seq(0, timelim, by = 0.001)
haz <- rep(0, length(tdom))
cut <- 40
for (i in 1:cut) {
low <- as.numeric(quantile(tdom,(i-1)/cut))
high <- as.numeric(quantile(tdom,(i)/cut))
if(i %% 2 == 1){
a <- runif(1,0,1)
if(a > 0.3) haz[tdom<=high & tdom > low] <- 0.01
else {
c <- tdom[tdom<=high & tdom > low]
haz[tdom<=high & tdom > low] <-(0.001) *(c-min(c))
}
}
if(i %% 2 == 0){
a <- runif(1,0,1)
if(a > 0.8){
c <- tdom[tdom<=high & tdom > low]
haz[tdom<=high & tdom > low] <- 0.25
}
else{
haz[tdom<=high & tdom > low] <- sample(c(0.001,0.002),size = 1,prob = c(0.5,0.5))
}
}
}
true <- data.frame(time = tdom, hazard = haz)
if(truth == "smooth"){
u <- runif(N)
x <- runif(N,min = 0, max = 6)
truefunc <- function(x) log((x + 1)^2) - 1
eta <- truefunc(x)
}
else{
u <- runif(N)
x <- runif(N,min = -5, max = 5)
truefunc <- function(x) 1.5*(sin(0.8*x))
eta <- truefunc(x)
}
failtimes <- c()
for (i in 1:N) {
hazz <- haz * exp(eta[i])
cumhaz <- cumsum(hazz*0.001)
Surv <- exp(-cumhaz)
failtimes[i] <- tdom[colSums(outer(Surv, u[i], `>`))]
}
data <- data_frame(x = x,times = failtimes, entry = rep(0,length(length(u))),censoring = ifelse(failtimes >= timelim,yes = 0, no=1))
for (i in 1:length(data$censoring)) {
if (data$censoring[i] == 1) {data$censoring[i] <- rbinom(n = 1,size = 1,prob = 0.9)}
}
data <- rename(data,exposure = x)
data <- data %>% as_tibble() %>%
mutate(exposure_binned = abcoxph:::bin_covariate(exposure,bins = RW2BINS,type = "equal"))
}
else{
timelim <- 200
tdom <- seq(0, timelim, by = 0.001)
haz <- rep(0, length(tdom))
haz[1:round(length(haz)/3)] <- 0.01*sin(0.85*tdom[1:round(length(haz)/3)]) + 0.02
haz[(round(length(haz)/3) + 1):(round(2*length(haz))/3)] <- 0.03 * cos(0.25*tdom[(round(length(haz)/3) + 1):(round(2*length(haz))/3)]) + 0.05
haz[(round(2*length(haz)/3) + 1):length(haz)] <- 0.01*sin(0.55*tdom[(round(2*length(haz)/3) + 1):length(haz)]) + 0.025
true <- data.frame(time = tdom, hazard = haz)
if(truth == "smooth"){
u <- runif(N)
x <- runif(N,min = 0, max = 6)
truefunc <- function(x) log((x + 1)^2) - 1
eta <- truefunc(x)
}
else{
u <- runif(N)
x <- runif(N,min = -5, max = 5)
truefunc <- function(x) 1.5*(sin(0.8*x))
eta <- truefunc(x)
}
failtimes <- c()
for (i in 1:N) {
hazz <- haz * exp(eta[i])
cumhaz <- cumsum(hazz*0.001)
Surv <- exp(-cumhaz)
failtimes[i] <- tdom[colSums(outer(Surv, u[i], `>`))]
}
data <- data_frame(x = x,times = failtimes, entry = rep(0,length(length(u))),censoring = ifelse(failtimes >= timelim,yes = 0, no=1))
for (i in 1:length(data$censoring)) {
if (data$censoring[i] == 1) {data$censoring[i] <- rbinom(n = 1,size = 1,prob = 0.9)}
}
data <- rename(data,exposure = x)
data <- data %>% as_tibble() %>%
mutate(exposure_binned = abcoxph:::bin_covariate(exposure,bins = RW2BINS,type = "equal"))
}
data
}
## simulate data:
set.seed(1234)
data <- Simulate_data(bas = "extreme", truth = "complicated", N = 500)
data <- abcoxph:::arrange_data(data)
dat <- tibble(x = data$exposure, t = data$times, cens = data$censoring)
dat$ranks <- rank(dat$t, ties.method = "min")
## setup smoothing part:
a <- min(dat$x)
b <- max(dat$x) # boundary
n <- nrow(dat)
# Order of spline
p <- 4 # 4 = cubic
# Order of derivative penalty
m <- 2
# Number of INTERIOR knots
d <- 42
# Number of knots
T <- d + 2*p
# The knots
intknots <- seq(a,b,length.out = d)
leftknots <- seq(min(intknots)-(p-1),min(intknots)-1,by=1)
rightknots <- seq(max(intknots)+1,max(intknots)+p-1,by=1)
splineknots <- sort(unique(c(leftknots,intknots,rightknots)))
construct_design <- function(x,splineknots,p,m) {
BD <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,m),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
BB <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,0),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
P <- BD$S[[1]] + BB$S[[1]] # O'sullivan spline "of the third kind"
P <- as(P,"dgTMatrix")
B <- BB$X
B <- as(B,"dgTMatrix")
B
}
construct_penalty <- function(x,splineknots,p,m) {
BD <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,m),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
BB <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,0),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
BD$S[[1]] + BB$S[[1]] # O'sullivan spline "of the third kind"
}
P <- as(construct_penalty(dat$x,splineknots,p,m),'dgTMatrix')
B <- as(construct_design(dat$x,splineknots,p,m),'dgTMatrix')
D <- abcoxph:::create_diff_matrix(n)
### Setup TMB:
tmbdat <- list(
# Design matrix
BX = B,
# Penalty matrix
P = P,
# Differencing matrix
D = D,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(P,logarithm = TRUE)$modulus),
# Response
ranks = as.integer(dat$ranks),
cens = as.integer(dat$cens),
# Prior params
u = 1,
alpha = 0.5
)
tmbparams <- list(
W = rep(0,ncol(B)), # W = c(U); U = B-Spline coefficients
theta = 0 # -2log(sigma)
)
compile("02_coxph_bspline.cpp")
dyn.load(dynlib("02_coxph_bspline"))
### Coxph B-Spline regression ###
library(tidyverse)
library(aghq)
library(mgcv)
library(Matrix)
library(TMB)
library(INLA)
library(tmbstan)
library(brinla)
precompile()
## Simulating function:
### Simulation Example
Simulate_data <- function(N = 500, bas, truth, RW2BINS = 50){
if(bas == "constant") {
timelim <- 200
tdom <- seq(0, timelim, by = 0.001)
haz <- rep(0, length(tdom))
haz <- 0*tdom + 0.03
true <- data.frame(time = tdom, hazard = haz)
if(truth == "smooth") {
u <- runif(N)
x <- runif(N,min = 0, max = 6)
truefunc <- function(x) log((x + 1)^2) - 1
eta <- truefunc(x)
}
else{
u <- runif(N)
x <- runif(N,min = -5, max = 5)
truefunc <- function(x) 1.5*(sin(0.8*x))
eta <- truefunc(x)
}
failtimes <- c()
for (i in 1:N) {
hazz <- haz * exp(eta[i])
cumhaz <- cumsum(hazz*0.001)
Surv <- exp(-cumhaz)
failtimes[i] <- tdom[colSums(outer(Surv, u[i], `>`))]
}
data <- data_frame(x = x,times = failtimes, entry = rep(0,length(length(u))),censoring = ifelse(failtimes >= timelim,yes = 0, no=1))
for (i in 1:length(data$censoring)) {
if (data$censoring[i] == 1) {data$censoring[i] <- rbinom(n = 1,size = 1,prob = 0.9)}
}
data <- rename(data,exposure = x)
data <- data %>% as_tibble() %>%
mutate(exposure_binned = abcoxph:::bin_covariate(exposure,bins = RW2BINS,type = "equal"))
}
else if (bas == "regular") {
timelim <- 200
tdom <- seq(0, timelim, by = 0.001)
haz <- rep(0, length(tdom))
haz <- 0.03 * cos(0.15*tdom) + 0.05
true <- data.frame(time = tdom, hazard = haz)
if(truth == "smooth"){
u <- runif(N)
x <- runif(N,min = 0, max = 6)
truefunc <- function(x) log((x + 1)^2) - 1
eta <- truefunc(x)
}
else{
u <- runif(N)
x <- runif(N,min = -5, max = 5)
truefunc <- function(x) 1.5*(sin(0.8*x))
eta <- truefunc(x)
}
failtimes <- c()
for (i in 1:N) {
hazz <- haz * exp(eta[i])
cumhaz <- cumsum(hazz*0.001)
Surv <- exp(-cumhaz)
failtimes[i] <- tdom[colSums(outer(Surv, u[i], `>`))]
}
data <- data_frame(x = x,times = failtimes, entry = rep(0,length(length(u))),censoring = ifelse(failtimes >= timelim,yes = 0, no=1))
for (i in 1:length(data$censoring)) {
if (data$censoring[i] == 1) {data$censoring[i] <- rbinom(n = 1,size = 1,prob = 0.9)}
}
data <- rename(data,exposure = x)
data <- data %>% as_tibble() %>%
mutate(exposure_binned = abcoxph:::bin_covariate(exposure,bins = RW2BINS,type = "equal"))
}
else if (bas == "three_pieces") {
timelim <- 300
tdom <- seq(0, timelim, by = 0.001)
haz <- rep(0, length(tdom))
haz[1:round(length(haz)/3)] <- 0.01
haz[(round(length(haz)/3) + 1):(round(1.5*length(haz))/3)] <- 0.25
haz[(round(1.5*length(haz)/3) + 1):length(haz)] <- 0.5
true <- data.frame(time = tdom, hazard = haz)
if(truth == "smooth"){
u <- runif(N)
x <- runif(N,min = 0, max = 6)
truefunc <- function(x) log((x + 1)^2) - 1
eta <- truefunc(x)
}
else{
u <- runif(N)
x <- runif(N,min = -5, max = 5)
truefunc <- function(x) 1.5*(sin(0.8*x))
eta <- truefunc(x)
}
failtimes <- c()
for (i in 1:N) {
hazz <- haz * exp(eta[i])
cumhaz <- cumsum(hazz*0.001)
Surv <- exp(-cumhaz)
failtimes[i] <- tdom[colSums(outer(Surv, u[i], `>`))]
}
data <- data_frame(x = x,times = failtimes, entry = rep(0,length(length(u))),censoring = ifelse(failtimes >= timelim,yes = 0, no=1))
for (i in 1:length(data$censoring)) {
if (data$censoring[i] == 1) {data$censoring[i] <- rbinom(n = 1,size = 1,prob = 0.9)}
}
data <- rename(data,exposure = x)
data <- data %>% as_tibble() %>%
mutate(exposure_binned = abcoxph:::bin_covariate(exposure,bins = RW2BINS,type = "equal"))
}
else if (bas == "extreme") {
timelim <- 300
tdom <- seq(0, timelim, by = 0.001)
haz <- rep(0, length(tdom))
cut <- 40
for (i in 1:cut) {
low <- as.numeric(quantile(tdom,(i-1)/cut))
high <- as.numeric(quantile(tdom,(i)/cut))
if(i %% 2 == 1){
a <- runif(1,0,1)
if(a > 0.3) haz[tdom<=high & tdom > low] <- 0.01
else {
c <- tdom[tdom<=high & tdom > low]
haz[tdom<=high & tdom > low] <-(0.001) *(c-min(c))
}
}
if(i %% 2 == 0){
a <- runif(1,0,1)
if(a > 0.8){
c <- tdom[tdom<=high & tdom > low]
haz[tdom<=high & tdom > low] <- 0.25
}
else{
haz[tdom<=high & tdom > low] <- sample(c(0.001,0.002),size = 1,prob = c(0.5,0.5))
}
}
}
true <- data.frame(time = tdom, hazard = haz)
if(truth == "smooth"){
u <- runif(N)
x <- runif(N,min = 0, max = 6)
truefunc <- function(x) log((x + 1)^2) - 1
eta <- truefunc(x)
}
else{
u <- runif(N)
x <- runif(N,min = -5, max = 5)
truefunc <- function(x) 1.5*(sin(0.8*x))
eta <- truefunc(x)
}
failtimes <- c()
for (i in 1:N) {
hazz <- haz * exp(eta[i])
cumhaz <- cumsum(hazz*0.001)
Surv <- exp(-cumhaz)
failtimes[i] <- tdom[colSums(outer(Surv, u[i], `>`))]
}
data <- data_frame(x = x,times = failtimes, entry = rep(0,length(length(u))),censoring = ifelse(failtimes >= timelim,yes = 0, no=1))
for (i in 1:length(data$censoring)) {
if (data$censoring[i] == 1) {data$censoring[i] <- rbinom(n = 1,size = 1,prob = 0.9)}
}
data <- rename(data,exposure = x)
data <- data %>% as_tibble() %>%
mutate(exposure_binned = abcoxph:::bin_covariate(exposure,bins = RW2BINS,type = "equal"))
}
else{
timelim <- 200
tdom <- seq(0, timelim, by = 0.001)
haz <- rep(0, length(tdom))
haz[1:round(length(haz)/3)] <- 0.01*sin(0.85*tdom[1:round(length(haz)/3)]) + 0.02
haz[(round(length(haz)/3) + 1):(round(2*length(haz))/3)] <- 0.03 * cos(0.25*tdom[(round(length(haz)/3) + 1):(round(2*length(haz))/3)]) + 0.05
haz[(round(2*length(haz)/3) + 1):length(haz)] <- 0.01*sin(0.55*tdom[(round(2*length(haz)/3) + 1):length(haz)]) + 0.025
true <- data.frame(time = tdom, hazard = haz)
if(truth == "smooth"){
u <- runif(N)
x <- runif(N,min = 0, max = 6)
truefunc <- function(x) log((x + 1)^2) - 1
eta <- truefunc(x)
}
else{
u <- runif(N)
x <- runif(N,min = -5, max = 5)
truefunc <- function(x) 1.5*(sin(0.8*x))
eta <- truefunc(x)
}
failtimes <- c()
for (i in 1:N) {
hazz <- haz * exp(eta[i])
cumhaz <- cumsum(hazz*0.001)
Surv <- exp(-cumhaz)
failtimes[i] <- tdom[colSums(outer(Surv, u[i], `>`))]
}
data <- data_frame(x = x,times = failtimes, entry = rep(0,length(length(u))),censoring = ifelse(failtimes >= timelim,yes = 0, no=1))
for (i in 1:length(data$censoring)) {
if (data$censoring[i] == 1) {data$censoring[i] <- rbinom(n = 1,size = 1,prob = 0.9)}
}
data <- rename(data,exposure = x)
data <- data %>% as_tibble() %>%
mutate(exposure_binned = abcoxph:::bin_covariate(exposure,bins = RW2BINS,type = "equal"))
}
data
}
## simulate data:
set.seed(1234)
data <- Simulate_data(bas = "extreme", truth = "complicated", N = 500)
data <- abcoxph:::arrange_data(data)
dat <- tibble(x = data$exposure, t = data$times, cens = data$censoring)
dat$ranks <- rank(dat$t, ties.method = "min")
## setup smoothing part:
a <- min(dat$x)
b <- max(dat$x) # boundary
n <- nrow(dat)
# Order of spline
p <- 4 # 4 = cubic
# Order of derivative penalty
m <- 2
# Number of INTERIOR knots
d <- 42
# Number of knots
T <- d + 2*p
# The knots
intknots <- seq(a,b,length.out = d)
leftknots <- seq(min(intknots)-(p-1),min(intknots)-1,by=1)
rightknots <- seq(max(intknots)+1,max(intknots)+p-1,by=1)
splineknots <- sort(unique(c(leftknots,intknots,rightknots)))
construct_design <- function(x,splineknots,p,m) {
BD <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,m),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
BB <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,0),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
P <- BD$S[[1]] + BB$S[[1]] # O'sullivan spline "of the third kind"
P <- as(P,"dgTMatrix")
B <- BB$X
B <- as(B,"dgTMatrix")
B
}
construct_penalty <- function(x,splineknots,p,m) {
BD <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,m),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
BB <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,0),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
BD$S[[1]] + BB$S[[1]] # O'sullivan spline "of the third kind"
}
P <- as(construct_penalty(dat$x,splineknots,p,m),'dgTMatrix')
B <- as(construct_design(dat$x,splineknots,p,m),'dgTMatrix')
D <- abcoxph:::create_diff_matrix(n)
### Setup TMB:
tmbdat <- list(
# Design matrix
BX = B,
# Penalty matrix
P = P,
# Differencing matrix
D = D,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(P,logarithm = TRUE)$modulus),
# Response
ranks = as.integer(dat$ranks),
cens = as.integer(dat$cens),
# Prior params
u = 1,
alpha = 0.5
)
tmbparams <- list(
W = rep(0,ncol(B)), # W = c(U); U = B-Spline coefficients
theta = 0 # -2log(sigma)
)
compile(file = "02_coxph_bspline.cpp")
