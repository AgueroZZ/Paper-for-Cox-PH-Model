ranks = as.integer(data$ranks),
cens = as.integer(data$cens),
# Prior params
u = 2,
alpha = 0.5
)
tmbparams <- list(
W = rep(0,ncol(BX)), # W = c(U); U = B-Spline coefficients
theta = 0 # -2log(sigma)
)
# TMB function template
# compile("01_coxph_leuk.cpp")
dyn.load(dynlib("01_coxph_leuk"))
start_time <- Sys.time()
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "01_coxph_leuk",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
quad <- aghq::marginal_laplace_tmb(ff,7,0)
eigen(P)
eigen(P,only.values = T)
eigen(P,only.values = T)$values
eigen(P,only.values = T)$values[1:(length(eigen(P,only.values = T)$values-2)]
eigen(P,only.values = T)$values[1:(length(eigen(P,only.values = T)$values)-2)]
sum(log(eigen(P,only.values = T)$values[1:(length(eigen(P,only.values = T)$values)-2)]))
precompile()
TEXT_SIZE = 25
### Setup_data:
set.seed(1234)
data <- Leuk %>% select(c("time","cens","age","sex","wbc","tpi"))
names(data)[1] <- "times"
data <- abcoxph:::arrange_data(data)
data$ranks <- rank(data$times, ties.method = "min")
hist(data$times,breaks = 100)
## setup smoothing part:
a <- min(data$tpi)
b <- max(data$tpi) # boundary
n <- nrow(data)
# Order of spline
p <- 4 # 4 = cubic
# Order of derivative penalty
m <- 2
# Number of INTERIOR knots
d <- 20
# Number of knots
T <- d + p
# The knots
intknots <- seq(a,b,length.out = d)
leftknots <- seq(min(intknots)-(p-1),min(intknots)-1,by=1)
rightknots <- seq(max(intknots)+1,max(intknots)+p-1,by=1)
splineknots <- sort(unique(c(leftknots,intknots,rightknots)))
construct_design <- function(x,splineknots,p,m) {
BB <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,0),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
B <- BB$X
B <- as(B,"dgTMatrix")
B
}
construct_penalty <- function(x,splineknots,p,m, noise = 0.0001) {
BD <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,m),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
BB <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,0),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
# BD$S[[1]] + BB$S[[1]] # O'sullivan spline "of the third kind"
BD$S[[1]] + diag(noise, ncol = ncol(BD$S[[1]]), nrow = nrow(BD$S[[1]])) #### add a very small noise to make the penalty matrix full rank
}
P <- as(construct_penalty(data$tpi,splineknots,p,m, noise = 0),'dgTMatrix')
B <- as(construct_design(data$tpi,splineknots,p,m),'dgTMatrix')
D <- abcoxph:::create_diff_matrix(n)
X <- as.matrix(data[,3:5])
BX <- as(cbind(B,X),'dgTMatrix')
### Setup TMB:
tmbdat <- list(
# Design matrix
BX = BX,
# Penalty matrix
P = P,
# Differencing matrix
D = D,
# Log determinant of penalty matrix (without the sigma part)
# logPdet = as.numeric(determinant(P,logarithm = TRUE)$modulus),
logPdet = sum(log(eigen(P,only.values = T)$values[1:(length(eigen(P,only.values = T)$values)-m)])),
# Response
ranks = as.integer(data$ranks),
cens = as.integer(data$cens),
# Prior params
u = 2,
alpha = 0.5
)
tmbparams <- list(
W = rep(0,ncol(BX)), # W = c(U); U = B-Spline coefficients
theta = 0 # -2log(sigma)
)
# TMB function template
# compile("01_coxph_leuk.cpp")
dyn.load(dynlib("01_coxph_leuk"))
start_time <- Sys.time()
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "01_coxph_leuk",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
quad <- aghq::marginal_laplace_tmb(ff,7,0)
precompile()
TEXT_SIZE = 25
### Setup_data:
set.seed(1234)
data <- Leuk %>% select(c("time","cens","age","sex","wbc","tpi"))
names(data)[1] <- "times"
data <- abcoxph:::arrange_data(data)
data$ranks <- rank(data$times, ties.method = "min")
hist(data$times,breaks = 100)
## setup smoothing part:
a <- min(data$tpi)
b <- max(data$tpi) # boundary
n <- nrow(data)
# Order of spline
p <- 4 # 4 = cubic
# Order of derivative penalty
m <- 2
# Number of INTERIOR knots
d <- 20
# Number of knots
T <- d + p
# The knots
intknots <- seq(a,b,length.out = d)
leftknots <- seq(min(intknots)-(p-1),min(intknots)-1,by=1)
rightknots <- seq(max(intknots)+1,max(intknots)+p-1,by=1)
splineknots <- sort(unique(c(leftknots,intknots,rightknots)))
construct_design <- function(x,splineknots,p,m) {
BB <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,0),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
B <- BB$X
B <- as(B,"dgTMatrix")
B
}
construct_penalty <- function(x,splineknots,p,m, noise = 0.0001) {
BD <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,m),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
BB <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,0),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
# BD$S[[1]] + BB$S[[1]] # O'sullivan spline "of the third kind"
BD$S[[1]] + diag(noise, ncol = ncol(BD$S[[1]]), nrow = nrow(BD$S[[1]])) #### add a very small noise to make the penalty matrix full rank
}
P <- as(construct_penalty(data$tpi,splineknots,p,m, noise = 0),'dgTMatrix')
B <- as(construct_design(data$tpi,splineknots,p,m),'dgTMatrix')
D <- abcoxph:::create_diff_matrix(n)
X <- as.matrix(data[,3:5])
BX <- as(cbind(B,X),'dgTMatrix')
### Setup TMB:
tmbdat <- list(
# Design matrix
BX = BX,
# Penalty matrix
P = P,
# Differencing matrix
D = D,
# Log determinant of penalty matrix (without the sigma part)
# logPdet = as.numeric(determinant(P,logarithm = TRUE)$modulus),
logPdet = sum(log(eigen(P,only.values = T)$values[1:(length(eigen(P,only.values = T)$values)-m)])),
# Response
ranks = as.integer(data$ranks),
cens = as.integer(data$cens),
# Prior params
u = 2,
alpha = 0.1
)
tmbparams <- list(
W = rep(0,ncol(BX)), # W = c(U); U = B-Spline coefficients
theta = 0 # -2log(sigma)
)
# TMB function template
# compile("01_coxph_leuk.cpp")
dyn.load(dynlib("01_coxph_leuk"))
start_time <- Sys.time()
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "01_coxph_leuk",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
quad <- aghq::marginal_laplace_tmb(ff,7,0)
precompile()
TEXT_SIZE = 25
### Setup_data:
set.seed(1234)
data <- Leuk %>% select(c("time","cens","age","sex","wbc","tpi"))
names(data)[1] <- "times"
data <- abcoxph:::arrange_data(data)
data$ranks <- rank(data$times, ties.method = "min")
hist(data$times,breaks = 100)
## setup smoothing part:
a <- min(data$tpi)
b <- max(data$tpi) # boundary
n <- nrow(data)
# Order of spline
p <- 4 # 4 = cubic
# Order of derivative penalty
m <- 2
# Number of INTERIOR knots
d <- 20
# Number of knots
T <- d + p
# The knots
intknots <- seq(a,b,length.out = d)
leftknots <- seq(min(intknots)-(p-1),min(intknots)-1,by=1)
rightknots <- seq(max(intknots)+1,max(intknots)+p-1,by=1)
splineknots <- sort(unique(c(leftknots,intknots,rightknots)))
construct_design <- function(x,splineknots,p,m) {
BB <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,0),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
B <- BB$X
B <- as(B,"dgTMatrix")
B
}
construct_penalty <- function(x,splineknots,p,m, noise = 0.0001) {
BD <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,m),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
BB <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,0),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
# BD$S[[1]] + BB$S[[1]] # O'sullivan spline "of the third kind"
BD$S[[1]] + diag(noise, ncol = ncol(BD$S[[1]]), nrow = nrow(BD$S[[1]])) #### add a very small noise to make the penalty matrix full rank
}
P <- as(construct_penalty(data$tpi,splineknots,p,m, noise = 0),'dgTMatrix')
B <- as(construct_design(data$tpi,splineknots,p,m),'dgTMatrix')
D <- abcoxph:::create_diff_matrix(n)
X <- as.matrix(data[,3:5])
BX <- as(cbind(B,X),'dgTMatrix')
### Setup TMB:
tmbdat <- list(
# Design matrix
BX = BX,
# Penalty matrix
P = P,
# Differencing matrix
D = D,
# Log determinant of penalty matrix (without the sigma part)
# logPdet = as.numeric(determinant(P,logarithm = TRUE)$modulus),
logPdet = sum(log(eigen(P,only.values = T)$values[1:(length(eigen(P,only.values = T)$values)-m)])),
# Response
ranks = as.integer(data$ranks),
cens = as.integer(data$cens),
# Prior params
u = 2,
alpha = 0.5
)
tmbparams <- list(
W = rep(0,ncol(BX)), # W = c(U); U = B-Spline coefficients
theta = 1 # -2log(sigma)
)
# TMB function template
# compile("01_coxph_leuk.cpp")
dyn.load(dynlib("01_coxph_leuk"))
start_time <- Sys.time()
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "01_coxph_leuk",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
quad <- aghq::marginal_laplace_tmb(ff,7,0)
precompile()
TEXT_SIZE = 25
### Setup_data:
set.seed(1234)
data <- Leuk %>% select(c("time","cens","age","sex","wbc","tpi"))
names(data)[1] <- "times"
data <- abcoxph:::arrange_data(data)
data$ranks <- rank(data$times, ties.method = "min")
hist(data$times,breaks = 100)
## setup smoothing part:
a <- min(data$tpi)
b <- max(data$tpi) # boundary
n <- nrow(data)
# Order of spline
p <- 4 # 4 = cubic
# Order of derivative penalty
m <- 2
# Number of INTERIOR knots
d <- 20
# Number of knots
T <- d + p
# The knots
intknots <- seq(a,b,length.out = d)
leftknots <- seq(min(intknots)-(p-1),min(intknots)-1,by=1)
rightknots <- seq(max(intknots)+1,max(intknots)+p-1,by=1)
splineknots <- sort(unique(c(leftknots,intknots,rightknots)))
construct_design <- function(x,splineknots,p,m) {
BB <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,0),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
B <- BB$X
B <- as(B,"dgTMatrix")
B
}
construct_penalty <- function(x,splineknots,p,m, noise = 0.0001) {
BD <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,m),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
BB <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,0),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
# BD$S[[1]] + BB$S[[1]] # O'sullivan spline "of the third kind"
BD$S[[1]] + diag(noise, ncol = ncol(BD$S[[1]]), nrow = nrow(BD$S[[1]])) #### add a very small noise to make the penalty matrix full rank
}
P <- as(construct_penalty(data$tpi,splineknots,p,m, noise = 0.0001),'dgTMatrix')
as.numeric(determinant(P,logarithm = TRUE)$modulus)
sum(log(eigen(P,only.values = T)$values[1:(length(eigen(P,only.values = T)$values)-m)]))
precompile()
TEXT_SIZE = 25
### Setup_data:
set.seed(1234)
data <- Leuk %>% select(c("time","cens","age","sex","wbc","tpi"))
names(data)[1] <- "times"
data <- abcoxph:::arrange_data(data)
data$ranks <- rank(data$times, ties.method = "min")
hist(data$times,breaks = 100)
## setup smoothing part:
a <- min(data$tpi)
b <- max(data$tpi) # boundary
n <- nrow(data)
# Order of spline
p <- 4 # 4 = cubic
# Order of derivative penalty
m <- 2
# Number of INTERIOR knots
d <- 20
# Number of knots
T <- d + p
# The knots
intknots <- seq(a,b,length.out = d)
leftknots <- seq(min(intknots)-(p-1),min(intknots)-1,by=1)
rightknots <- seq(max(intknots)+1,max(intknots)+p-1,by=1)
splineknots <- sort(unique(c(leftknots,intknots,rightknots)))
construct_design <- function(x,splineknots,p,m) {
BB <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,0),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
B <- BB$X
B <- as(B,"dgTMatrix")
B
}
construct_penalty <- function(x,splineknots,p,m, noise = 0.0001) {
BD <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,m),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
BB <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,0),k=length(splineknots)-p),data = data.frame(x = x),knots = list(x = splineknots))
# BD$S[[1]] + BB$S[[1]] # O'sullivan spline "of the third kind"
BD$S[[1]] + diag(noise, ncol = ncol(BD$S[[1]]), nrow = nrow(BD$S[[1]])) #### add a very small noise to make the penalty matrix full rank
}
P <- as(construct_penalty(data$tpi,splineknots,p,m, noise = 0.0001),'dgTMatrix')
B <- as(construct_design(data$tpi,splineknots,p,m),'dgTMatrix')
D <- abcoxph:::create_diff_matrix(n)
X <- as.matrix(data[,3:5])
BX <- as(cbind(B,X),'dgTMatrix')
### Setup TMB:
tmbdat <- list(
# Design matrix
BX = BX,
# Penalty matrix
P = P,
# Differencing matrix
D = D,
# Log determinant of penalty matrix (without the sigma part)
# logPdet = as.numeric(determinant(P,logarithm = TRUE)$modulus),
logPdet = sum(log(eigen(P,only.values = T)$values[1:(length(eigen(P,only.values = T)$values)-m)])),
# Response
ranks = as.integer(data$ranks),
cens = as.integer(data$cens),
# Prior params
u = 2,
alpha = 0.5
)
tmbparams <- list(
W = rep(0,ncol(BX)), # W = c(U); U = B-Spline coefficients
theta = 0 # -2log(sigma)
)
# TMB function template
# compile("01_coxph_leuk.cpp")
dyn.load(dynlib("01_coxph_leuk"))
start_time <- Sys.time()
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "01_coxph_leuk",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
quad <- aghq::marginal_laplace_tmb(ff,7,0)
# Plot of theta posterior
logpostsigma <- compute_pdf_and_cdf(quad$marginals[[1]],list(totheta = function(x) -2*log(x),fromtheta = function(x) exp(-x/2)), interpolation = "spline")
with(logpostsigma,plot(transparam,pdf_transparam,type='l'))
# Inference for W
samps <- sample_marginal(quad,3000,interpolation = "spline")
end_time <- Sys.time()
runtime_aghq <- end_time - start_time
# Plot of curve
# Posterior mean
W <- apply(samps$samps,1,mean)
U <- W[1:ncol(P)]
beta <- W[(ncol(P)+1):ncol(BX)]
# Construct a plot
plotx <- seq(a,b,by=0.01)
plotdat <- data.frame(x = plotx)
plotB <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,0),k=length(splineknots)-p),data = plotdat,knots = list(x = splineknots))$X
# Construct the plot
ploteta <- plotB %*% U
ploteta <- ploteta - mean(ploteta)
plot(plotx,ploteta,type='l',ylim=c(-0.5,0.5))
# Plot the samples
samplestoplot <- samps$samps[ ,sample(1:ncol(samps$samps),200,replace = FALSE)]
for (i in 1:ncol(samplestoplot)) {
WS <- samplestoplot[ ,i]
US <- WS[1:ncol(P)]
plotetaS <- plotB %*% US
plotetaS <- plotetaS - mean(plotetaS)
lines(plotx,plotetaS,col = 'lightgray')
}
lines(plotx,ploteta)
### Setup TMB:
tmbdat <- list(
# Design matrix
BX = BX,
# Penalty matrix
P = P,
# Differencing matrix
D = D,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(P,logarithm = TRUE)$modulus),
# logPdet = sum(log(eigen(P,only.values = T)$values[1:(length(eigen(P,only.values = T)$values)-m)])),
# Response
ranks = as.integer(data$ranks),
cens = as.integer(data$cens),
# Prior params
u = 2,
alpha = 0.5
)
tmbparams <- list(
W = rep(0,ncol(BX)), # W = c(U); U = B-Spline coefficients
theta = 0 # -2log(sigma)
)
# TMB function template
# compile("01_coxph_leuk.cpp")
dyn.load(dynlib("01_coxph_leuk"))
start_time <- Sys.time()
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "01_coxph_leuk",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
quad <- aghq::marginal_laplace_tmb(ff,7,0)
# Plot of theta posterior
logpostsigma <- compute_pdf_and_cdf(quad$marginals[[1]],list(totheta = function(x) -2*log(x),fromtheta = function(x) exp(-x/2)), interpolation = "spline")
with(logpostsigma,plot(transparam,pdf_transparam,type='l'))
# Inference for W
samps <- sample_marginal(quad,3000,interpolation = "spline")
end_time <- Sys.time()
runtime_aghq <- end_time - start_time
# Plot of curve
# Posterior mean
W <- apply(samps$samps,1,mean)
U <- W[1:ncol(P)]
beta <- W[(ncol(P)+1):ncol(BX)]
# Construct a plot
plotx <- seq(a,b,by=0.01)
plotdat <- data.frame(x = plotx)
plotB <- mgcv::smooth.construct(s(x,bs='bs',m=c(p-1,0),k=length(splineknots)-p),data = plotdat,knots = list(x = splineknots))$X
# Construct the plot
ploteta <- plotB %*% U
ploteta <- ploteta - mean(ploteta)
plot(plotx,ploteta,type='l',ylim=c(-0.5,0.5))
# Plot the samples
samplestoplot <- samps$samps[ ,sample(1:ncol(samps$samps),200,replace = FALSE)]
for (i in 1:ncol(samplestoplot)) {
WS <- samplestoplot[ ,i]
US <- WS[1:ncol(P)]
plotetaS <- plotB %*% US
plotetaS <- plotetaS - mean(plotetaS)
lines(plotx,plotetaS,col = 'lightgray')
}
lines(plotx,ploteta)
eigen(P,only.values = T)
demo("Tokyo-compare")
system.file("demo/Tokyo-compare.R", package="INLA")
demo("Tokyo-compare")
### INLA:
prior.prec <- list(prec = list(prior = "pc.prec",
param = c(tmbdat$u, tmbdat$a)))
data$tpi_binned <- abcoxph:::bin_covariate(data$tpi,bins = 50, type = "equal")
formula <- inla.surv(times,cens) ~ age + sex + wbc + f(tpi_binned,model = 'rw2',constr = T, hyper = prior.prec)
Inlaresult <- inla(formula = formula,data = data, family = "coxph")
fhat <- Inlaresult$summary.random$tpi_binned$mean
fup <- Inlaresult$summary.random$tpi_binned$`0.975quant`
flo <- Inlaresult$summary.random$tpi_binned$`0.025quant`
plotINLA <- data.frame(x = Inlaresult$summary.random$tpi_binned$ID, f = fhat, up = fup, lo = flo)
plot(plotINLA$x,plotINLA$f,type = 'l',ylim = c(-0.5,0.5))
lines(plotINLA$x,plotINLA$up,type='l',lty='dashed')
lines(plotINLA$x,plotINLA$lo,type='l',lty='dashed')
### INLA's inferred baseline
INLA_base <- bri.basehaz.plot(Inlaresult, plot = F)
INLA_base$basehaz <- exp(INLA_base$basehaz)
INLA_base <- data.frame(INLA_base)
ggplot(INLA_base, aes(time,basehaz)) + geom_line()
inla_mcmc <- inla(formula = formula,data = data, family = "coxph", keep = TRUE, inla.arg = "-m mcmc -N 5000 -T 10 -S 1")
inla_mcmc <- inla(formula = formula,data = data, family = "coxph", keep = TRUE, inla.arg = "-m mcmc -N 5000 -T 10 -S 1", verbose = T)
